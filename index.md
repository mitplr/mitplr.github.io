---
# Feel free to add content and custom Front Matter to this file.
# To modify the layout, see https://jekyllrb.com/docs/themes/#overriding-theme-defaults

#layout: home
---

![MIT Programming Languages Review logo](mitplr2023.png)

# MIT Programming Languages Review

The mission of the MIT PL Review is to highlight recent developments that we believe have significant potential to shape the future direction of PL research and/or industry practice. We aim to select papers that may substantially transform the PL community and beyond, with a focus on emerging trends rather than established lines of research. We favor papers whose contributions are broadly accessible (and likely to be appreciated) across the PL community, but we do not limit the papers to those published at PL venues. Our selection process is not meant to provide an objective evaluation of works but rather to highlight and celebrate works that resonated with our committee members.

We will be holding the PL Review on May 30, 2023 at MIT in the Ray and Maria Stata Center (32 Vassar Street), room 32-155.
The event will begin at 9:00am with talks starting at 10:00am and concluding at 5:00pm.
Virtual attendees can participate though our Slack workspace and attend talks via Zoom.
[Register now!](https://mit.co1.qualtrics.com/jfe/form/SV_7Qy1V7rAlX1IASi)

# Selected Papers

## Satisfiability modulo fuzzing: a synergistic combination of SMT solving and fuzzing

Notes from the program committee:

> This paper presents a neat idea to unify two widely used, highly impactful "black-box" techniques. Many papers in PL rely on SMT solvers, but very few actually advance the state of the art. We believe the ideas in this work will open the applicability of SMT solvers to a wider range of applications, and also inspire deeper inquiries into the tools we often take for granted.

Read the paper [here](https://dl.acm.org/doi/pdf/10.1145/3563332)

## Staged Compilation with Two-Level Type Theory

Notes from the program committee:

> We believe that this work will broaden the scope of metaprogramming for dependent type theory, a key feature closely tied to the practical use of said theories. The current state of the art, embodied by tactic systems in theorem provers like Coq and Lean, is limited since tactics live in an untrusted world outside the space of verifiable programs. We expect that by integrating metaprogramming into the core of a theorem prover, such systems can simultaneously increase the scope of metaprogramming features while moving some key existing features from the trusted kernel into verified libraries.

Read the paper [here](https://dl.acm.org/doi/pdf/10.1145/3547641)

## A Compositional Atlas of Tractable Circuit Operations for Probabilistic Inference

Notes from the program committee:

> This paper stands out for its axiomatic approach, and we appreciate that its theoretical contributions will be palatable to a wide audience. It also provides a solid foundation for future developments in probabilistic circuits, a class of efficient probabilistic programs. We hope that this work can motivate the programming languages community to explore ways in which the techniques from our field apply to the domain of inference.

Read the paper [here](https://proceedings.neurips.cc/paper_files/paper/2021/hash/6e01383fd96a17ae51cc3e15447e7533-Abstract.html)

## The Role of Working Memory in Program Tracing

Notes from the program committee:

> This work leverages well-established concepts from cognitive psychology regarding working memory to explore the types of techniques and mistakes that affect programmers as they conduct program tracing. With this methodology, the authors were able to formulate and test well-supported claims about tracing errors based on existing psychology principles and make principled recommendations for the future design of programming tools. Not only are the conclusions drawn by this project potentially influential on future tool design, we believe this kind of interdisciplinarily-motivated approach will be more widely adopted.

Read the paper [here](https://dl.acm.org/doi/pdf/10.1145/3411764.3445257)

## Predictable Accelerator Design with Time-Sensitive Affine Types

Notes from the program committee:

> In the world of high-performance systems, types and formal methods have gained traction as tools to prove correctness and soundness of optimizations. This project proposes a type system that provides a principled way to predictably reason about accelerator design performance and shore down the vast design space. This type of work demonstrates the potential of programming languages methods in HPC spaces to not only reason about correctness but also performance.

Read the paper [here](https://dl.acm.org/doi/pdf/10.1145/3385412.3385974)

## PDL: A High-Level Hardware Design Language for Pipelined Processors

Notes from the program committee:

> This paper brings safety via abstraction, a key benefit of programming language techniques, to hardware pipeline design. Existing tooling for hardware design does not adequately support safety guarantees, and we hope that this work will push the field towards the benefits of static enforcement mechanisms in this critical application domain without sacrificing performance goals.

Read the paper [here](https://dl.acm.org/doi/abs/10.1145/3519939.3523455)

## A Flexible Type System for Fearless Concurrency

Notes from the program committee:

> This work adds support for a large and important class of data structures to the ecosystem of practical substructural languages. Given the great success of Rust in the last decade and the clear desire for better ways to represent these structures in the Rust ecosystem, we believe that the type system designed in this paper will influence the next generation of substructural languages and eventually make its way into standard industry use.

Read the paper [here](https://dl.acm.org/doi/pdf/10.1145/3519939.3523443)

## Frequent Background Polling on a Shared Thread, using Light-Weight Compiler Interrupts

Notes from the program committee:

> This paper brings the attention of the PL community towards advances in hardware and recent trends in systems research. We believe this paper provides an example of how compiler techniques can be used to remove the cost of abstractions that were previously handled at runtime by hardware. We also hope this work will motivate further exploration of more such use cases for compiler techniques. 

Read the paper [here](https://dl.acm.org/doi/10.1145/3453483.3454107)

## You Only Linearize Once

Notes from the program committee:

> The principled application of type theory in this paper yields one of the cleanest frameworks for deep learning. We believe there is much untapped research potential within ML for PL researchers, and are excited to see more work of a similar flavor in the coming years.

Read the paper [here](https://dl.acm.org/doi/pdf/10.1145/3571236)


# Schedule

Time | Event
---|---
9-10 | Breakfast |
10-10:30 | Satisfiability modulo fuzzing: a synergistic combination of SMT solving and fuzzing
10:30-11 | Staged Compilation with Two-Level Type Theory
11-11:30 | A Compositional Atlas of Tractable Circuit Operations for Probabilistic Inference 
11:30-12:30 | Lunch
12:30-1 | The Role of Working Memory in Program Tracing
1-1:30 | Predictable Accelerator Design with Time-Sensitive Affine Types
1:30-2 | Frequent Background Polling on a Shared Thread, using Light-Weight Compiler Interrupts
2-2:30 | Coffee Break
2:30-3 | PDL: A High-Level Hardware Design Language for Pipelined Processors
3-3:30 | A Flexible Type System for Fearless Concurrency
3:30-4 | You Only Linearize Once
4-5 | MIT Faculty Panel: *Future of Programming Languages*

# PL Review Program Committee

- Ajay Brahmakshatriya
- Alex Renda
- Amanda Liu (Conference Chair)
- Charles Jin
- Dustin Jamner (Program Chair)
- Matt Bowers
- Tom Chen
- Yuka Ikarashi
